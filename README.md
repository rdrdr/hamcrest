Introduction
============

Hamcrest is a fluent framework for declarative Matcher objects
that, when applied to input values, produce self-describing
results.

Installation:
========

To install, run `all.bash`.

Alternatively, run `make install` in each package that you wish to use,
starting with `hamcrest` and `hamcrest/asserter`.  Keep in mind that a
few of the packages have dependencies on other packages.

Packages
========

`hamcrest.go` comes in several packages that you assemble to fit your needs:

*   `hamcrest`:  Defines the types `Matcher` and `Result`, provides factory
    functions to create them, and defines several core Matchers:
    `Is`, `Anything`, `True`, `False`, `Nil`, `DeeplyEqualTo`, `AnyOf`, and
    `AllOf`.

*   `hamcrest/collections`:  Matchers on arrays/slices and maps, such as
    `EachElement`, `EveryElement`, `EachMapElement`, `EveryMapElement`.

*   `hamcrest/comparison`:  Comparison matchers for >=, <=, >, <, ==, and !=.

*   `hamcrest/logic`:   Matchers for compound logical statements:
    `Not`, `And`, `Or`, `Nor`, `Xor`, `If/Then`, and `Iff`.

*   `hamcrest/reflect`:  Matchers using type reflection, such as `ToType`,
    `SameTypeAs`, `SliceOf`, `MapOf`, etc.

*   `hamcrest/strings`:  Matchers for strings.

*   `hamcrest/asserter`:  Defines an `Asserter` that can be used in conjunction 
    with Hamcrest Matchers to produce helpful logging messages at runtime
    (to stdout, stderr, or any object that implements io.Writer) or in
    unit tests (using `testing.T` from Go's standard `testing` package).

    Note: the asserter package isn't *really* part of Hamcrest:  it's just
    a handy way of using the Hamcrest results in conjunction with the
    standard Go testing package.

You may also choose to write your own Matchers (see *Custom matchers*, below).


How to use hamcrest at runtime:
===============================

Create an Asserter.  (The simplest way to do this is with the factory
method that logs problems to stderr and calls `panic` on `FailNow`.)
	import "hamcrest/asserter"
	var we = asserter.UsingStderr()

Use that asserter at initialization time to make sure globals are
properly initialized:
	import (
		"hamcrest/collections"
		"hamcrest/strings"
	)
	var hostnames = []string { "foo.mydomain.com", "bar.mydomain.com" }
	func init() {
		eachElement := collections.EachElement
		isForMyDomain := strings.EndsWith(".mydomain.com")
		we.FailNowUnless(hostnames, eachElement(isForMyDomain))
	}

Or use it at runtime to guarantee that a method's preconditions are met:
	func WriteTo(filename string) bool {
		we.AssertThat(filename, EndsWith(".txt").Comment("Must have txt extension."))
		// Use filename here.
	}

Note:  Since Hamcrest matchers allocate Description and Result objects
to explain in great detail why they did or did not match, users should
be generally aware of this cost when using matchers inside performance-
critical loops.

How to use hamcrest for testing:
================================

To use Hamcrest matchers, create an `Asserter` and use it to
`Check` or `Assert` that values meet the criteria of those
matchers:

	func TestPoint(t *testing.T) {
		p := Point(3, 4)
		we := asserter.Using(t)
		we.AssertThat(p.X, EqualTo(3).Comment("x coord"))
		we.AssertThat(p.Y, EqualTo(4).Comment("y coord"))
		we.CheckThat(p, ToString(EqualTo("[3, 4]")))
		we.CheckThat(p.Magnitude(), EqualTo(5).Comment("magnitude"))
	}

(`Assert` methods fail immediately, as `testing.T.FailNow()` does,
while `Check` methods defer failure, as `testing.T.Fail()` does.)

The `AssertThat` and `CheckThat` functions are designed to create
conditional checks that read fluently as self-commenting code, and
are self-describing when failures occur.  For example, the above
test might fail with this message:
	
	FAILURE on input &Point{X:3, Y:4}
		Did not match ToString(EqualTo([3, 4]))
		Because: String() was "[4, 3]"
			Did not match EqualTo[[3, 4]]
			Because: "[4, 3]" was not equal to "[3, 4]"

Or:
	FAILURE on input 5
		Did not match EqualTo(5)
		Because: uint 5 could not be compared to int 5
		Comment: magnitude

Note that the majority of the text descriptions are generated
automatically by the matchers.  For typical uses of Hamcrest
matchers, the code is largely self-documenting, and the error
messages are detailed.

Effort invested in good self-describing matchers can be leveraged
across many tests.


A note on library design:
=========================

Hamcrest is designed to be a fluent library.  The Go syntax requires external
symbols be preceded by their package name, which can lead to occasionally
awkward constructions:
	we.CheckThat("foobar", hamcrest.AllOf(strings.StartsWith("foo"), strings.EndsWith("bar")))

To avoid this clunkiness, Hamcrest matchers are generated by functions that
you can assign to local names:
	AllOf := hamcrest.AllOf
	HasPrefix := strings.StartsWith
	HasSuffix := strings.EndsWith
	we.CheckThat("foobar", AllOf(HasPrefix("foo"), HasSuffix("bar")))


A tour of common matchers
=========================

Hamcrest comes with a library of useful matchers. Here are some of the most
common ones.

  * `Anything` - matches any input
  * `DeeplyEqualTo(obj)` - matches any object `x` where `reflect.DeepEquals(x, obj)` is true
  * `True` - only matches bool `true`
  * `False` - only matches bool `false`
  * `Not(matcher)` - logical not of `matcher`
  * `Nil` - matches objects whose types have an `IsNil()` method  which returns true for the object
  * `NonNil` - inverse of `Nil` matcher (equivalent to `Not(Nil)`)
  * `AnyOf(matchers...)` - short-circuiting n-ary logical Or
  * `AllOf(matchers...)` - short-circuiting n-ary logical And

Syntactic sugar
===============

Hamcrest strives to make your tests as readable as possible. For example,
the `Is` matcher is a wrapper that doesn't add any extra behavior to the
underlying matcher. The following assertions are equivalent:

    we.AssertThat(x, EqualTo(y));
    we.AssertThat(x, Is(EqualTo(y)))
    
Similarly, it is possible to simulate common logical conditions using the `logic`
package for readability:

  * `Is(matcher)` - equivalent to `matcher`
  * `Both(matcher1).And(matcher2)` - short-circuiting logical `And`, equivalent to `AllOf(matcher1, matcher2)`
  * `Either(matcher1).Or(matcher2)` - short-circuiting logical `Or`, equivalent to `AnyOf(matcher1, matcher2)`
  * `Neither(matcher1).Nor(matcher2)` - short-circuiting logical `Nor`
  * `If(matcher1).Then(matcher2)` - short-circuiting logical `If/Then`
  * `Iff(matcher1).Then(matcher2)` - logical `IfAndOnlyIf` (note: iff never short-circuits)
  * `Either(matcher1).Xor(matcher)` - logical `Xor` (note: xor never short-circuits)

    
Custom matchers
===============

Example:

    func IsMultipleOf(k int) *hamcrest.Matcher {
        match := func(actual interface{}) {
            if n, ok := actual.(int); ok {
                if n % k == 0 {
                    why := NewDescription("%v is a multiple of %v", n, k))
                    return NewResult(true, why)
                }
                why := NewDescription("%v is not a multiple of %v", n, k))
                return NewResult(false, why)
            }
            why := NewDescription("can't convert %T[%v] to int", actual, actual))
            return NewResult(false, why)
        }
        return NewMatcher(hamcrest.NewDescription("multiple of %v", n), match)
    }

And used:
    we.CheckThat(recordSize, IsMultipleOf(8).Comment(
        "profiling suggests better performance than 4"))

